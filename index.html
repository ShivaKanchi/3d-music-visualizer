<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Music Equalizer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    canvas {
      display: block;
    }

    #upload-icon-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      font-family: sans-serif;
      color: #fff;
      text-align: center;
      cursor: pointer;
      font-size: 60px;
      /* Adjust size as needed */
      border: 1px solid #fff;
      /* padding: 20px; */
      height: 55px;
      width: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #file-info-bottom {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      font-family: sans-serif;
      color: #fff;
      font-size: 14px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      display: none;
      /* Hidden initially */
      align-items: center;
    }

    #file-name-bottom {
      margin-right: 8px;
      /* Space between file name and remove button */
    }

    #remove-file-bottom {
      cursor: pointer;
      font-weight: bold;
    }

    #hidden-file-input {
      display: none;
      /* Hide the actual file input */
    }

    /* Instruction icon (uses native title attribute for tooltip) */
    #tooltip-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      /* moved to right bottom */
      left: auto;
      cursor: pointer;
      color: #fff;
      z-index: 10;
      font-size: 20px;
    }

    /* Popup styles for song selection */
    .popup {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 50;
    }

    .popup-content {
      background: #0f0f10;
      color: #fff;
      padding: 18px;
      border-radius: 8px;
      width: min(540px, 90%);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .popup-header h2 {
      margin: 0;
      font-size: 18px;
    }

    .close-modal-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .song-list ul {
      list-style: none;
      padding: 0;
      margin: 0 0 10px 0;
      max-height: 240px;
      overflow: auto;
    }

    .song-list li {
      padding: 8px 10px;
      margin: 6px 0;
      background: #151517;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .song-list li:hover {
      background: #1f1f21;
    }

    .song-item-content {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .play-icon {
      color: #fff;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <!-- Instruction icon uses native title attribute for tooltip -->
  <div id="tooltip-container" title="Click to play default audio">
    <i class="fas fa-play"></i>
  </div>
  <input type="file" id="hidden-file-input" accept="audio/*" />
  <div id="upload-icon-container">
    <span>+</span>
  </div>
  <!-- Song selection popup: choose a predefined song or upload -->
  <div id="song-selection-popup" class="popup" aria-hidden="true">
    <div class="popup-content">
      <div class="popup-header">
        <h2>Choose a song</h2>
        <button class="close-modal-btn" id="close-modal-btn">×</button>
      </div>
      <div class="song-list">
        <ul id="predefined-songs">
          <!-- Populated by JS -->
        </ul>
      </div>
    </div>
  </div>
  <div id="file-info-bottom">
    <span id="file-name-bottom"></span>
    <span id="remove-file-bottom">x</span>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
    integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="js/modal.js"></script>
  <script src="js/player.js"></script>
  <script src="js/visualizer.js"></script>
  <script>
    // Function to create a specified number of lines
    function createLines(count) {
      // Remove existing lines before creating new ones if this is a re-creation
      if (lines.length > 0) {
        lines.forEach((line) => scene.remove(line));
        lines.length = 0;
      }

      const material = new THREE.LineBasicMaterial({ vertexColors: true }); // Material with vertex colors
      const color = new THREE.Color();

      const linesPerSection = Math.floor(count / 3); // Divide lines into three sections

      for (let i = 0; i < count; i++) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3); // 2 vertices (start and end) * 3 components (x, y, z)
        const colors = new Float32Array(2 * 3); // 2 vertices * 3 components (r, g, b)

        // Initial positions (starting at the center)
        positions[0] = 0; // Start X
        positions[1] = 0; // Start Y
        positions[2] = 0; // Start Z
        positions[3] = 0; // End X (initially same as start)
        positions[4] = 0; // End Y (initially same as start)
        positions[5] = 0; // End Z (initially same as start)

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const line = new THREE.Line(geometry, material); // Create a Line object
        // Store initial orientation (random direction outwards from center)
        const phi = Math.acos(Math.random() * 2 - 1);
        const theta = Math.random() * Math.PI * 2;
        line.userData.direction = new THREE.Vector3(
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi)
        ).normalize();

        // Add rotation speed to line data
        line.userData.rotationSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * 0.015,
          (Math.random() - 0.5) * 0.015,
          (Math.random() - 0.5) * 0.015
        );

        // Assign frequency range based on section
        let frequencyRange;
        // Assign colors based on index to approximate inner/middle/outer distribution
        if (i < linesPerSection) {
          frequencyRange = "bass"; // Inner lines
        } else if (i < linesPerSection * 2) {
          frequencyRange = "mids"; // Middle lines
        } else {
          frequencyRange = "treble"; // Outer lines
        }
        line.userData.frequencyRange = frequencyRange;

        // Assign a completely random initial color to this line
        const initialColor = new THREE.Color(
          Math.random(),
          Math.random(),
          Math.random()
        );
        line.userData.initialColor = initialColor; // Store the random initial color

        // Set the initial vertex colors
        colors[0] = initialColor.r;
        colors[1] = initialColor.g;
        colors[2] = initialColor.b;
        colors[3] = initialColor.r;
        colors[4] = initialColor.g;
        colors[5] = initialColor.b;

        // Lines originate from the center, so no initial position needed for the line object itself
        line.position.set(0, 0, 0);

        scene.add(line);
        lines.push(line);
      }
    }

    // Popup open/close and population logic
    function openSongPopup() {
      const popup = document.getElementById("song-selection-popup");
      if (popup) {
        popup.style.display = "flex";
        popup.setAttribute("aria-hidden", "false");
        populateSongList();
      }
    }

    function closeSongPopup() {
      const popup = document.getElementById("song-selection-popup");
      if (popup) {
        popup.style.display = "none";
        popup.setAttribute("aria-hidden", "true");
      }
    }

    function populateSongList() {
      const ul = document.getElementById("predefined-songs");
      if (!ul) return;
      ul.innerHTML = "";
      // Try fetching metadata file to build list of available songs
      fetch("data/music-metadata.json")
        .then((res) => res.json())
        .then((data) => {
          // metadata may include multiple fields; support filename or tracks
          const entries = [];
          if (Array.isArray(data.tracks) && data.tracks.length) {
            data.tracks.forEach((t, idx) => {
              entries.push({
                name: t.title || t.filename || "Track " + (idx + 1),
                file: t.filename || t.file || t.src,
                viz: t.viz || "spiral",
              });
            });
          } else if (data.filename) {
            entries.push({
              name: data.title || data.filename,
              file: data.filename,
              viz: data.viz || "spiral",
            });
          }
          // Fallback if metadata didn't give any entries
          if (entries.length === 0) {
            entries.push({
              name: "Default song",
              file: data.filename || "",
              viz: "spiral",
            });
          }

          entries.forEach((entry) => {
            const li = document.createElement("li");
            const songContent = document.createElement("div");
            songContent.className = "song-item-content";

            // Add play icon
            const playIcon = document.createElement("i");
            playIcon.className = "fas fa-play play-icon";

            // Add song name
            const songName = document.createElement("span");
            songName.textContent = entry.name;

            songContent.appendChild(playIcon);
            songContent.appendChild(songName);

            li.appendChild(songContent);
            li.dataset.file = entry.file;
            li.dataset.viz = entry.viz || "spiral";

            li.addEventListener("click", () => {
              closeSongPopup();
              if (li.dataset.file) {
                currentVisualization = li.dataset.viz || "spiral";
                loadAudioFromUrl("music/" + li.dataset.file);
              }
            });
            ul.appendChild(li);
          });
        })
        .catch(() => {
          // Fallback hardcoded list
          const fallback = [
            {
              name: "Default (provided)",
              file: "default.mp3",
              viz: "", // spiral
            },
          ];
          fallback.forEach((entry) => {
            const li = document.createElement("li");
            const songContent = document.createElement("div");
            songContent.className = "song-item-content";

            // Add play icon
            const playIcon = document.createElement("i");
            playIcon.className = "fas fa-play play-icon";

            // Add song name
            const songName = document.createElement("span");
            songName.textContent = entry.name;

            songContent.appendChild(playIcon);
            songContent.appendChild(songName);

            li.appendChild(songContent);
            li.dataset.file = entry.file;
            li.dataset.viz = entry.viz;

            li.addEventListener("click", () => {
              closeSongPopup();
              currentVisualization = entry.viz;
              loadAudioFromUrl("music/" + entry.file);
            });
            ul.appendChild(li);
          });
        });
    }

    // Function to create a particle system (stars)
    function createStars() {
      const starCount = 40000; // Number of stars
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = []; // Buffer attribute for individual sizes
      const lifes = []; // Buffer attribute for particle life/fading
      const color = new THREE.Color();
      starData = []; // Clear previous star data

      // Predefined color palette for stars (more vibrant)
      const starColors = [
        0xffffff,
        0xf8f8ff,
        0xf0f8ff, // Shades of white
        0xe0ffff,
        0xafeeee,
        0xb0e0e6, // Light blues/cyans
        0xffffe0,
        0xfffacd, // Pale yellows
        0xf5f5dc,
        0xf0fff0, // Off-whites/greens
        0xffe4e1,
        0xffdab9, // Subtle pinks/orangestarColors
        0xdda0dd,
        0xee82ee, // Purple shades
        0xadd8e6,
        0x87cefa, // Sky blue shades
        0x90ee90,
        0x98fb98, // Light green shades
      ];

      for (let i = 0; i < starCount; i++) {
        // Random position in a large sphere (universe)
        const radius = Math.random() * 800 + 100; // Further out
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        positions.push(x, y, z);

        // Assign a random color to each particle
        color.set(starColors[Math.floor(Math.random() * starColors.length)]);
        colors.push(color.r, color.g, color.b);

        // Assign a random initial size
        const initialSize = Math.random() * 0.4 + 0.1; // Size between 0.1 and 0.5
        sizes.push(initialSize);
        lifes.push(1.0); // Start with full life

        // Store data for shooting stars
        starData.push({
          isShooting: false,
          shootingDirection: new THREE.Vector3(),
          shootingSpeed: 0,
          initialPosition: new THREE.Vector3(x, y, z), // Store initial position
          life: 1.0, // Life for fading and sizing
          initialSize: initialSize, // Store initial size
        });
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      ); // Use vertex colors
      geometry.setAttribute(
        "size",
        new THREE.Float32BufferAttribute(sizes, 1)
      ); // Add size attribute
      geometry.setAttribute(
        "life",
        new THREE.Float32BufferAttribute(lifes, 1)
      ); // Add life attribute

      const material = new THREE.PointsMaterial({
        size: 1, // Base size (will be scaled by the size attribute)
        sizeAttenuation: true, // Size is affected by distance
        vertexColors: true, // Use colors from the geometry
        transparent: true,
        opacity: 1.0, // Initial opacity (will be scaled by the life attribute)
        blending: THREE.AdditiveBlending, // Additive blending for glowing effect
      });

      stars = new THREE.Points(geometry, material);
      scene.add(stars);
    }

    // Initialize the Web Audio API
    function initAudio(audioBuffer) {
      // Initialize Three.js visuals when audio starts (if not already)
      if (!window.scene) {
        if (typeof initThree === "function") initThree();
      }
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      source = audioContext.createBufferSource();

      source.buffer = audioBuffer; // Set the decoded audio data
      source.connect(analyser); // Connect source to analyser
      analyser.connect(audioContext.destination); // Connect analyser to speakers

      analyser.fftSize = 1024; // Decreased for faster response (must be power of 2)
      analyser.smoothingTimeConstant = 0.5; // Lower smoothing for snappier response (0-1)
      analyser.minDecibels = -90; // Minimum power value for scaling
      analyser.maxDecibels = -10; // Maximum power value for scaling

      const bufferLength = analyser.frequencyBinCount; // Number of data points available
      dataArray = new Uint8Array(bufferLength); // Array to hold the frequency data

      // Calculate frequency ranges based on bufferLength - Better distribution
      frequencyRanges = {
        bass: [0, Math.floor(bufferLength * 0.1)], // Lower frequencies (20-250 Hz)
        mids: [
          Math.floor(bufferLength * 0.1),
          Math.floor(bufferLength * 0.4),
        ], // Mid frequencies (250-2000 Hz)
        treble: [Math.floor(bufferLength * 0.4), Math.floor(bufferLength * 0.85)], // High frequencies (2000-8000 Hz)
      };

      source.start(0); // Start playing the audio immediately
      // Hide both icons now that music is playing
      setIconsVisible(false);
    }

    // Handle file selection
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          // Use a temporary context for decoding so we don’t overwrite the active 'audioContext' yet
          const decodingContext = new (window.AudioContext || window.webkitAudioContext)();
          decodingContext.decodeAudioData(
            e.target.result,
            function (buffer) {
              // Successfully decoded. Now stop any previous audio and close old context.
              stopAudio();

              // Initialize audio with the new buffer (this creates a new main 'audioContext')
              initAudio(buffer);

              // We can close the decoding context now (buffers are independent)
              decodingContext.close();

              // Display file name and remove option at the bottom
              setIconsVisible(false);
              document.getElementById("file-info-bottom").style.display = "flex";
              document.getElementById("file-name-bottom").textContent = file.name;
            },
            function (e) {
              console.error("Error decoding audio data", e);
              // Clean up decoding context even on error
              decodingContext.close();
              resetAudio();
            }
          );
        };
        reader.readAsArrayBuffer(file); // Read the file as an ArrayBuffer
      }
    }

    // Helper to stop audio and invalidte context without manipulating UI
    function stopAudio() {
      if (source) {
        try { source.stop(); } catch (e) { }
        try { source.disconnect(); } catch (e) { }
        source = null;
      }
      if (audioContext) {
        try { audioContext.close(); } catch (e) { }
        audioContext = null;
      }
      analyser = null;
      dataArray = null;
    }

    // Reset audio and UI
    function resetAudio() {
      stopAudio();

      // Reset UI
      // Show icons again when audio is stopped/reset
      setIconsVisible(true);
      document.getElementById("file-info-bottom").style.display = "none";
      document.getElementById("file-name-bottom").textContent = "";
      document.getElementById("hidden-file-input").value = ""; // Clear the file input

      // Optionally clear lines or reset their state if needed
      lines.forEach((line) => {
        const positions = line.geometry.attributes.position.array;
        positions[3] = 0;
        positions[4] = 0;
        positions[5] = 0; // Reset line length
        line.geometry.attributes.position.needsUpdate = true;
      });
    }

    // Function to add a line with a specific frequency range and color
    function addLine(frequencyRange, color) {
      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(2 * 3);
      const colors = new Float32Array(2 * 3);

      positions[0] = 0;
      positions[1] = 0;
      positions[2] = 0;
      positions[3] = 0;
      positions[4] = 0;
      positions[5] = 0;

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const line = new THREE.Line(geometry, material);

      const phi = Math.acos(Math.random() * 2 - 1);
      const theta = Math.random() * Math.PI * 2;
      line.userData.direction = new THREE.Vector3(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      ).normalize();

      line.userData.rotationSpeed = new THREE.Vector3(
        (Math.random() - 0.5) * 0.015,
        (Math.random() - 0.5) * 0.015,
        (Math.random() - 0.5) * 0.015
      );

      line.userData.frequencyRange = frequencyRange;
      line.userData.initialColor = color; // Store the color

      colors[0] = color.r;
      colors[1] = color.g;
      colors[2] = color.b;
      colors[3] = color.r;
      colors[4] = color.g;
      colors[5] = color.b;

      scene.add(line);
      lines.push(line);
    }

    // Function to remove a random line
    function removeLine() {
      if (lines.length > 0) {
        const randomIndex = Math.floor(Math.random() * lines.length);
        const lineToRemove = lines[randomIndex];
        scene.remove(lineToRemove);
        lineToRemove.geometry.dispose();
        lineToRemove.material.dispose();
        lines.splice(randomIndex, 1);
      }
    }

    // Animation loop for the equalizer and visualization
    function animateEqualizer() {
      requestAnimationFrame(animateEqualizer);

      // Removed the rotation based on mouseX here

      if (analyser && dataArray) {
        // Auto-rotate scene slowly if not dragging (idle state)
        if (!isDragging) {
          scene.rotation.y += 0.0001;
        }

        analyser.getByteFrequencyData(dataArray); // Get frequency data

        const dataArrayLength = dataArray.length;
        const color = new THREE.Color();

        // Calculate overall spectral complexity
        let totalAmplitude = 0;
        let activeBins = 0;
        const amplitudeThreshold = 15; // Lowered threshold for better sensitivity

        for (let i = 0; i < dataArrayLength; i++) {
          totalAmplitude += dataArray[i];
          if (dataArray[i] > amplitudeThreshold) {
            activeBins++;
          }
        }
        const averageAmplitude = totalAmplitude / dataArrayLength;
        const normalizedAverageAmplitude = averageAmplitude / 255;

        // Determine target line count based on complexity
        // Simple mapping: more active bins = more lines
        const complexityFactor = activeBins / dataArrayLength; // Ratio of active bins
        let targetLineCount = Math.round(
          minLineCount + complexityFactor * (maxLineCount - minLineCount)
        );
        targetLineCount = Math.max(
          minLineCount,
          Math.min(maxLineCount, targetLineCount)
        ); // Clamp within min/max

        // Adjust line count dynamically - but limit changes per frame for smoother transitions
        const maxLinesPerFrame = 25; // Increase this to allow faster transitions during drops
        let linesAdded = 0;

        while (lines.length < targetLineCount && linesAdded < maxLinesPerFrame) {
          // Add lines, distributing across frequency ranges with their assigned initial color
          const linesPerSection = Math.floor(targetLineCount / 3);
          let frequencyRangeToAdd;
          // Add new lines with random colors
          const colorToAdd = new THREE.Color(
            Math.random(),
            Math.random(),
            Math.random()
          ); // Completely random color

          // Simple logic to try and balance ranges when adding
          const bassLines = lines.filter(
            (line) => line.userData.frequencyRange === "bass"
          ).length;
          const midsLines = lines.filter(
            (line) => line.userData.frequencyRange === "mids"
          ).length;
          const trebleLines = lines.filter(
            (line) => line.userData.frequencyRange === "treble"
          ).length;

          if (bassLines <= midsLines && bassLines <= trebleLines) {
            frequencyRangeToAdd = "bass";
          } else if (midsLines <= bassLines && midsLines <= trebleLines) {
            frequencyRangeToAdd = "mids";
          } else {
            frequencyRangeToAdd = "treble";
          }
          addLine(frequencyRangeToAdd, colorToAdd);
          linesAdded++;
        }

        let linesRemoved = 0;
        while (lines.length > targetLineCount && linesRemoved < maxLinesPerFrame) {
          removeLine();
          linesRemoved++;
        }

        lines.forEach((line, i) => {
          const positions = line.geometry.attributes.position.array;
          const colors = line.geometry.attributes.color.array;

          // Determine the frequency range for this line
          const range = frequencyRanges[line.userData.frequencyRange];

          const startIndex = range[0];
          const endIndex = range[1];
          const rangeLength = endIndex - startIndex + 1;

          // Calculate the average amplitude for this line's frequency range
          let averageAmplitude = 0;
          if (rangeLength > 0) {
            for (let j = startIndex; j <= endIndex; j++) {
              averageAmplitude += dataArray[j];
            }
            averageAmplitude /= rangeLength;
          }
          const normalizedAmplitude = averageAmplitude / 255; // Normalize to 0-1

          // Apply non-linear scaling for more dramatic and responsive effect
          const dramaticAmplitude = Math.pow(normalizedAmplitude, 1.5); // Better balance between low and high values

          // Scale line length based on dramatic amplitude - Increased for more visible response
          const extendedLength = dramaticAmplitude * 80; // Increased multiplier for better visibility

          // Calculate the end point of the line based on amplitude and direction and extended length
          let endPoint;
          if (currentVisualization === "spiral") {
            // Arrange lines in a spiral / circular pattern that responds to amplitude
            const angle =
              (i / lines.length) * Math.PI * 8 + performance.now() * 0.0005;
            const radius = 20 + extendedLength * 2;
            endPoint = new THREE.Vector3(
              Math.cos(angle) * radius,
              Math.sin(angle) * radius,
              (i / lines.length - 0.5) * 60 + extendedLength
            );
          } else {
            endPoint = line.userData.direction
              .clone()
              .multiplyScalar(extendedLength);
          }

          // Update the end vertex position
          positions[3] = endPoint.x;
          positions[4] = endPoint.y;
          positions[5] = endPoint.z;

          // Update vertex colors based on amplitude and the line's current color (either initial or random)
          // Use the stored initialColor as the base for HSL adjustment
          const baseColor = line.userData.initialColor;
          const hsl = { h: 0, s: 0, l: 0 }; // Temporary object for HSL values
          baseColor.getHSL(hsl); // Get HSL from the base color

          // Adjust both saturation and lightness based on amplitude for more dynamic colors
          const minLightness = 0.3; // Minimum lightness (brighter minimum)
          const maxLightness = 0.95; // Maximum lightness
          const lightnessRange = maxLightness - minLightness;
          const adjustedLightness =
            minLightness + normalizedAmplitude * lightnessRange;

          // Also boost saturation when amplitude is high
          const minSaturation = Math.max(0.3, hsl.s * 0.5); // Keep some base saturation
          const maxSaturation = 1.0;
          const saturationRange = maxSaturation - minSaturation;
          const adjustedSaturation =
            minSaturation + normalizedAmplitude * saturationRange;

          color.setHSL(hsl.h, adjustedSaturation, adjustedLightness); // Set color using adjusted HSL

          colors[0] = color.r; // Color of the start vertex
          colors[1] = color.g;
          colors[2] = color.b;
          colors[3] = color.r; // Color of the end vertex
          colors[4] = color.g;
          colors[5] = color.b;

          line.geometry.attributes.position.needsUpdate = true; // Mark positions as needing update
          line.geometry.attributes.color.needsUpdate = true; // Mark colors as needing update

          // Apply rotation
          line.rotation.x += line.userData.rotationSpeed.x;
          line.rotation.y += line.userData.rotationSpeed.y;
          line.rotation.z += line.userData.rotationSpeed.z;
        });
      }

      // Animate stars (subtle movement and shooting stars)
      if (stars && starData.length > 0) {
        const starPositions = stars.geometry.attributes.position.array;
        const starSizes = stars.geometry.attributes.size.array; // Get sizes array
        const starLifes = stars.geometry.attributes.life.array; // Get lifes array
        const starColorsArray = stars.geometry.attributes.color.array; // Get colors array
        const starCountActual = stars.geometry.attributes.position.count;
        const currentTime = performance.now();
        const deltaTime =
          (currentTime - (animateEqualizer.lastTime || currentTime)) / 1000; // Delta time in seconds
        animateEqualizer.lastTime = currentTime;

        for (let i = 0; i < starCountActual; i++) {
          const starIndex = i * 3;
          const currentStarData = starData[i];

          if (currentStarData.isShooting) {
            // Move the shooting star
            starPositions[starIndex] +=
              currentStarData.shootingDirection.x *
              currentStarData.shootingSpeed *
              deltaTime *
              60; // Scale by delta time
            starPositions[starIndex + 1] +=
              currentStarData.shootingDirection.y *
              currentStarData.shootingSpeed *
              deltaTime *
              60;
            starPositions[starIndex + 2] +=
              currentStarData.shootingDirection.z *
              currentStarData.shootingSpeed *
              deltaTime *
              60;

            // Decrease life
            currentStarData.life -= deltaTime / (shootingStarDuration / 1000); // Decrease life based on duration
            currentStarData.life = Math.max(0, currentStarData.life); // Clamp life to 0

            // Update life attribute for fading (if using alpha in material)
            starLifes[i] = currentStarData.life;

            // Update size based on life (grows then shrinks)
            const sizeFactor = 1.0 - currentStarData.life; // Goes from 0 to 1 as life goes from 1 to 0
            starSizes[i] = currentStarData.initialSize + sizeFactor * 1.5; // Grows up to 1.5 units larger

            // Check if the shooting star has faded out
            if (currentStarData.life <= 0) {
              // Reset to a new random position and stop shooting
              const radius = Math.random() * 800 + 100;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(Math.random() * 2 - 1);
              starPositions[starIndex] =
                radius * Math.sin(phi) * Math.cos(theta);
              starPositions[starIndex + 1] =
                radius * Math.sin(phi) * Math.sin(theta);
              starPositions[starIndex + 2] = radius * Math.cos(phi);

              currentStarData.initialPosition.set(
                starPositions[starIndex],
                starPositions[starIndex + 1],
                starPositions[starPositions[starIndex + 2]]
              ); // Update initial position

              currentStarData.isShooting = false;
              currentStarData.life = 1.0; // Reset life
              starLifes[i] = 1.0; // Reset life attribute
              starSizes[i] = currentStarData.initialSize; // Reset size attribute
              isShootingStarActive = false; // Allow a new shooting star
            }
          } else {
            // Subtle random drift for non-shooting stars
            starPositions[starIndex] +=
              (Math.random() - 0.5) * 0.01 * deltaTime * 60; // Scale by delta time
            starPositions[starIndex + 1] +=
              (Math.random() - 0.5) * 0.01 * deltaTime * 60;
            starPositions[starIndex + 2] +=
              (Math.random() - 0.5) * 0.01 * deltaTime * 60;

            // Keep non-shooting stars within a large boundary
            const starPos = new THREE.Vector3(
              starPositions[starIndex],
              starPositions[starIndex + 1],
              starPositions[starIndex + 2]
            );
            if (starPos.length() > 900) {
              const radius = Math.random() * 800 + 50;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(Math.random() * 2 - 1);
              starPositions[starIndex] =
                radius * Math.sin(phi) * Math.cos(theta);
              starPositions[starIndex + 1] =
                radius * Math.sin(phi) * Math.sin(theta);
              starPositions[starIndex + 2] = radius * Math.cos(phi);
              // Update initial position when resetting
              currentStarData.initialPosition.set(
                starPositions[starIndex],
                starPositions[starIndex + 1],
                starPositions[starIndex + 2]
              );
            }

            // Occasionally make a star a shooting star, respecting the interval and active state
            if (
              !isShootingStarActive &&
              currentTime - lastShootingStarTime > shootingStarInterval &&
              Math.random() < 0.0002
            ) {
              // Adjusted probability
              // Find a non-shooting star to make it a shooting star
              if (!currentStarData.isShooting) {
                currentStarData.isShooting = true;
                isShootingStarActive = true; // Set flag that a shooting star is active
                lastShootingStarTime = currentTime; // Record the time
                currentStarData.life = 1.0; // Reset life for the new shooting star

                // Random shooting direction
                currentStarData.shootingDirection
                  .set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                  )
                  .normalize();
                currentStarData.shootingSpeed = Math.random() * 2 + 1; // Random shooting speed
                // Start the shooting star from its current position
                currentStarData.initialPosition.set(
                  starPositions[starIndex],
                  starPositions[starIndex + 1],
                  starPositions[starIndex + 2]
                );
                break; // Only make one shooting star at a time
              }
            }
          }
        }
        stars.geometry.attributes.position.needsUpdate = true; // Important to update the buffer geometry
        stars.geometry.attributes.size.needsUpdate = true; // Update sizes
        stars.geometry.attributes.life.needsUpdate = true; // Update life for opacity
      }

      // Move camera based on mouse position (only if not dragging)
      if (!isDragging) {
        camera.position.x += (mouseX * 0.04 - camera.position.x) * 0.01; // Slower camera movement
        camera.position.y += (-mouseY * 0.04 - camera.position.y) * 0.01;
        camera.lookAt(scene.position); // Make camera look at the center of the scene
      }

      renderer.render(scene, camera);
    }

    // Handle mouse movement for camera control (only if not dragging)
    function onDocumentMouseMove(event) {
      if (!isDragging) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }
    }

    // Handle mouse wheel for zooming
    function onDocumentMouseWheel(event) {
      // Adjust camera position based on wheel direction
      camera.position.z += event.deltaY * 0.2; // Zoom in/out by changing Z position

      // Optional: Limit zoom range
      camera.position.z = Math.max(40, Math.min(600, camera.position.z)); // Adjusted zoom limits
    }

    // Handle click on the canvas - Change line colors to new random colors
    function onCanvasClick(event) {
      lines.forEach((line) => {
        // Assign a new completely random color to this line's vertices
        const newRandomColor = new THREE.Color(
          Math.random(),
          Math.random(),
          Math.random()
        );
        const colors = line.geometry.attributes.color.array;
        for (let i = 0; i < colors.length; i += 3) {
          colors[i] = newRandomColor.r;
          colors[i + 1] = newRandomColor.g;
          colors[i + 2] = newRandomColor.b;
        }
        line.geometry.attributes.color.needsUpdate = true;
        // Update the initialColor in userData so the brightness scaling uses the new random color
        line.userData.initialColor = newRandomColor;
      });
    }

    // Handle mouse down for dragging
    function onMouseDown(event) {
      isDragging = true;
      previousMouseX = event.clientX;
      previousMouseY = event.clientY;
    }

    // Handle mouse up for dragging
    function onMouseUp(event) {
      isDragging = false;
    }

    // Handle mouse move for dragging and rotation
    function onMouseMove(event) {
      if (isDragging) {
        const deltaX = event.clientX - previousMouseX;
        const deltaY = event.clientY - previousMouseY;

        // Rotate the scene based on mouse movement
        // Lowered sensitivity for slower drag speed
        scene.rotation.y += deltaX * 0.002; // Reduced multiplier
        scene.rotation.x += deltaY * 0.002; // Reduced multiplier

        previousMouseX = event.clientX;
        previousMouseY = event.clientY;
      } else {
        // Update mouse position for camera control when not dragging
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }
    }

    // Handle window resize
    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // On window load, only set up small UI pieces. Three.js is
    // initialized when audio starts playing (see `initAudio`).
    window.onload = function () {
      if (window.movePlayIconToBottomRight)
        window.movePlayIconToBottomRight();
    };

    function playDefaultAudio() {
      fetch("data/music-metadata.json")
        .then((response) => response.json())
        .then((data) => {
          const audioUrl = "music/" + data.filename;
          loadAudioFromUrl(audioUrl);
        })
        .catch((error) =>
          console.error("Error fetching music metadata:", error)
        );
    }

    function loadAudioFromUrl(url) {
      const request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";

      request.onload = function () {
        // Use temporary context for decoding
        const decodingContext = new (window.AudioContext || window.webkitAudioContext)();
        decodingContext.decodeAudioData(
          request.response,
          function (buffer) {
            // Clean up old audio resources first
            stopAudio();

            initAudio(buffer);

            // Close decoding context
            decodingContext.close();

            document.getElementById("upload-icon-container").style.display = "none";
            document.getElementById("file-info-bottom").style.display = "flex";
            document.getElementById("file-name-bottom").textContent = url.split("/").pop();
          },
          function (e) {
            console.error("Error decoding audio data", e);
            decodingContext.close();
            resetAudio();
          }
        );
      };

      request.send();
    }
  </script>
</body>

</html>