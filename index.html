<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Music Equalizer</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
        <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { display: block; }
        #upload-icon-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-family: sans-serif;
            color: #fff;
            text-align: center;
            cursor: pointer;
            font-size: 60px; /* Adjust size as needed */
            border: 1px solid #fff;
            /* padding: 20px; */
            height: 55px;

            width: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.5);
        }
        #file-info-bottom {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-family: sans-serif;
            color: #fff;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            display: none; /* Hidden initially */
            align-items: center;
        }
        #file-name-bottom {
            margin-right: 8px; /* Space between file name and remove button */
        }
        #remove-file-bottom {
            cursor: pointer;
            font-weight: bold;
        }
        #hidden-file-input {
            display: none; /* Hide the actual file input */
        }
        #tooltip-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            cursor: pointer;
            color: #fff;
        }
        #tooltip-container .tooltip-text {
            visibility: hidden;
            width: 160px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -80px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        </style>
    </head>
    <body>
        <div id="tooltip-container">
            <i class="fas fa-play"></i>
            <span class="tooltip-text">Click to play default audio</span>
        </div>
        <input type="file" id="hidden-file-input" accept="audio/*">
        <div id="upload-icon-container">
            <span>+</span>
        </div>
        <div id="file-info-bottom">
            <span id="file-name-bottom"></span>
            <span id="remove-file-bottom">x</span>
        </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        let scene, camera, renderer, analyser, dataArray, source, audioContext;
        let lines = []; // Array for the lines
        let stars; // The star particle system
        let starData = []; // To store additional data per star (like shooting state, size, life)
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        // Shooting star control variables
        let isShootingStarActive = false;
        let lastShootingStarTime = 0;
        const shootingStarInterval = 3000; // 3 seconds in milliseconds - Increased frequency
        const shootingStarDuration = 1500; // Duration of shooting star effect in milliseconds

        // Mouse interaction variables
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        // Initial camera position
        const initialCameraZ = 100;
        const baseLineCount = 150; // Base number of lines
        const maxLineCount = 200; // Maximum number of lines
        const minLineCount = 50; // Minimum number of lines


        // Frequency range variables
        let frequencyRanges = {}; // To store the calculated frequency bin indices

        // Removed initialFrequencyColors as lines will start with random colors

        // Predefined color palette for stars (more vibrant)
        const starColors = [
            0xffffff, 0xf8f8ff, 0xf0f8ff, // Shades of white
            0xe0ffff, 0xafeeee, 0xb0e0e6, // Light blues/cyans
            0xffffe0, 0xfffacd, // Pale yellows
            0xf5f5dc, 0xf0fff0, // Off-whites/greens
             0xffe4e1, 0xffdab9, // Subtle pinks/oranges
             0xdda0dd, 0xee82ee, // Purple shades
             0xadd8e6, 0x87cefa, // Sky blue shades
             0x90ee90, 0x98fb98  // Light green shades
        ];


        // Initialize the Three.js scene
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = initialCameraZ;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create initial lines
            createLines(baseLineCount);

            // Create the stars background
            createStars();

            // No need for strong directional lights with LineBasicMaterial
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient light
            scene.add(ambientLight);


            // Add event listeners for interactivity
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('wheel', onDocumentMouseWheel, false); // Add mouse wheel listener
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false); // Add click listener for color change
            renderer.domElement.addEventListener('mousedown', onMouseDown, false); // Add mouse down listener
            renderer.domElement.addEventListener('mouseup', onMouseUp, false); // Add mouse up listener
            renderer.domElement.addEventListener('mousemove', onMouseMove, false); // Add mouse move listener for dragging

            // Add event listeners for the custom upload interface
            document.getElementById('upload-icon-container').addEventListener('click', () => {
                document.getElementById('hidden-file-input').click();
            });
            document.getElementById('hidden-file-input').addEventListener('change', handleFileSelect);
            document.getElementById('remove-file-bottom').addEventListener('click', resetAudio);
            document.getElementById('tooltip-container').addEventListener('click', playDefaultAudio);
        }

        // Function to create a specified number of lines
        function createLines(count) {
             // Remove existing lines before creating new ones if this is a re-creation
             if (lines.length > 0) {
                 lines.forEach(line => scene.remove(line));
                 lines.length = 0;
             }

            const material = new THREE.LineBasicMaterial({ vertexColors: true }); // Material with vertex colors
            const color = new THREE.Color();

            const linesPerSection = Math.floor(count / 3); // Divide lines into three sections

            for (let i = 0; i < count; i++) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(2 * 3); // 2 vertices (start and end) * 3 components (x, y, z)
                const colors = new Float32Array(2 * 3); // 2 vertices * 3 components (r, g, b)

                // Initial positions (starting at the center)
                positions[0] = 0; // Start X
                positions[1] = 0; // Start Y
                positions[2] = 0; // Start Z
                positions[3] = 0; // End X (initially same as start)
                positions[4] = 0; // End Y (initially same as start)
                positions[5] = 0; // End Z (initially same as start)


                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const line = new THREE.Line(geometry, material); // Create a Line object
                 // Store initial orientation (random direction outwards from center)
                 const phi = Math.acos((Math.random() * 2) - 1);
                 const theta = Math.random() * Math.PI * 2;
                 line.userData.direction = new THREE.Vector3(
                     Math.sin(phi) * Math.cos(theta),
                     Math.sin(phi) * Math.sin(theta),
                     Math.cos(phi)
                 ).normalize();

                 // Add rotation speed to line data
                 line.userData.rotationSpeed = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.015,
                     (Math.random() - 0.5) * 0.015,
                     (Math.random() - 0.5) * 0.015
                 );

                 // Assign frequency range based on section
                 let frequencyRange;
                 // Assign colors based on index to approximate inner/middle/outer distribution
                 if (i < linesPerSection) {
                     frequencyRange = 'bass'; // Inner lines
                 } else if (i < linesPerSection * 2) {
                     frequencyRange = 'mids'; // Middle lines
                 } else {
                     frequencyRange = 'treble'; // Outer lines
                 }
                 line.userData.frequencyRange = frequencyRange;


                 // Assign a completely random initial color to this line
                 const initialColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                 line.userData.initialColor = initialColor; // Store the random initial color


                 // Set the initial vertex colors
                 colors[0] = initialColor.r;
                 colors[1] = initialColor.g;
                 colors[2] = initialColor.b;
                 colors[3] = initialColor.r;
                 colors[4] = initialColor.g;
                 colors[5] = initialColor.b;


                 // Lines originate from the center, so no initial position needed for the line object itself
                 line.position.set(0, 0, 0);


                scene.add(line);
                lines.push(line);
            }
        }

        // Function to create a particle system (stars)
        function createStars() {
            const starCount = 40000; // Number of stars
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = []; // Buffer attribute for individual sizes
            const lifes = []; // Buffer attribute for particle life/fading
            const color = new THREE.Color();
            starData = []; // Clear previous star data

            // Predefined color palette for stars (more vibrant)
            const starColors = [
                0xffffff, 0xf8f8ff, 0xf0f8ff, // Shades of white
                0xe0ffff, 0xafeeee, 0xb0e0e6, // Light blues/cyans
                0xffffe0, 0xfffacd, // Pale yellows
                0xf5f5dc, 0xf0fff0, // Off-whites/greens
                 0xffe4e1, 0xffdab9, // Subtle pinks/orangestarColors
                 0xdda0dd, 0xee82ee, // Purple shades
                 0xadd8e6, 0x87cefa, // Sky blue shades
                 0x90ee90, 0x98fb98  // Light green shades
            ];


            for (let i = 0; i < starCount; i++) {
                // Random position in a large sphere (universe)
                const radius = Math.random() * 800 + 100; // Further out
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                positions.push(x, y, z);

                // Assign a random color to each particle
                color.set(starColors[Math.floor(Math.random() * starColors.length)]);
                colors.push(color.r, color.g, color.b);

                // Assign a random initial size
                const initialSize = Math.random() * 0.4 + 0.1; // Size between 0.1 and 0.5
                sizes.push(initialSize);
                lifes.push(1.0); // Start with full life

                // Store data for shooting stars
                starData.push({
                    isShooting: false,
                    shootingDirection: new THREE.Vector3(),
                    shootingSpeed: 0,
                    initialPosition: new THREE.Vector3(x, y, z), // Store initial position
                    life: 1.0, // Life for fading and sizing
                    initialSize: initialSize // Store initial size
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // Use vertex colors
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); // Add size attribute
            geometry.setAttribute('life', new THREE.Float32BufferAttribute(lifes, 1)); // Add life attribute

            const material = new THREE.PointsMaterial({
                size: 1, // Base size (will be scaled by the size attribute)
                sizeAttenuation: true, // Size is affected by distance
                vertexColors: true, // Use colors from the geometry
                transparent: true,
                opacity: 1.0, // Initial opacity (will be scaled by the life attribute)
                blending: THREE.AdditiveBlending // Additive blending for glowing effect
            });

            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }


        // Initialize the Web Audio API
        function initAudio(audioBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            source = audioContext.createBufferSource();

            source.buffer = audioBuffer; // Set the decoded audio data
            source.connect(analyser); // Connect source to analyser
            analyser.connect(audioContext.destination); // Connect analyser to speakers

            analyser.fftSize = 512; // Size of the FFT to be performed (must be power of 2)
            const bufferLength = analyser.frequencyBinCount; // Number of data points available
            dataArray = new Uint8Array(bufferLength); // Array to hold the frequency data

            // Calculate frequency ranges based on bufferLength
            frequencyRanges = {
                bass: [0, Math.floor(bufferLength * 0.15)], // Adjusted example ranges
                mids: [Math.floor(bufferLength * 0.15), Math.floor(bufferLength * 0.6)],
                treble: [Math.floor(bufferLength * 0.6), bufferLength - 1]
            };

            source.start(0); // Start playing the audio immediately
            animateEqualizer(); // Start the animation loop
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Decode audio data
                    audioContext = new (window.AudioContext || window.webkitAudioContext)(); // Create context here for decoding
                    audioContext.decodeAudioData(e.target.result, function(buffer) {
                        // Stop previous audio if playing
                        if (source) {
                            source.stop();
                            source.disconnect();
                        }

                        initAudio(buffer); // Initialize audio with the new buffer

                        // Display file name and remove option at the bottom
                        document.getElementById('upload-icon-container').style.display = 'none';
                        document.getElementById('file-info-bottom').style.display = 'flex';
                        document.getElementById('file-name-bottom').textContent = file.name;

                    }, function(e) {
                        console.error("Error decoding audio data", e);
                         // Reset UI if decoding fails
                        resetAudio();
                    });
                };
                reader.readAsArrayBuffer(file); // Read the file as an ArrayBuffer
            }
        }

        // Reset audio and UI
        function resetAudio() {
            if (source) {
                source.stop();
                source.disconnect();
                source = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            analyser = null;
            dataArray = null;

            // Reset UI
            document.getElementById('upload-icon-container').style.display = 'flex';
            document.getElementById('file-info-bottom').style.display = 'none';
            document.getElementById('file-name-bottom').textContent = '';
             document.getElementById('hidden-file-input').value = ''; // Clear the file input

             // Optionally clear lines or reset their state if needed
             lines.forEach(line => {
                 const positions = line.geometry.attributes.position.array;
                 positions[3] = 0; positions[4] = 0; positions[5] = 0; // Reset line length
                 line.geometry.attributes.position.needsUpdate = true;
             });

        }

        // Function to add a line with a specific frequency range and color
        function addLine(frequencyRange, color) {
            const material = new THREE.LineBasicMaterial({ vertexColors: true });
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(2 * 3);
            const colors = new Float32Array(2 * 3);

            positions[0] = 0; positions[1] = 0; positions[2] = 0;
            positions[3] = 0; positions[4] = 0; positions[5] = 0;

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const line = new THREE.Line(geometry, material);

            const phi = Math.acos((Math.random() * 2) - 1);
            const theta = Math.random() * Math.PI * 2;
            line.userData.direction = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ).normalize();

            line.userData.rotationSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.015,
                (Math.random() - 0.5) * 0.015,
                (Math.random() - 0.5) * 0.015
            );

            line.userData.frequencyRange = frequencyRange;
            line.userData.initialColor = color; // Store the color

            colors[0] = color.r; colors[1] = color.g; colors[2] = color.b;
            colors[3] = color.r; colors[4] = color.g; colors[5] = color.b;

            scene.add(line);
            lines.push(line);
        }

        // Function to remove a random line
        function removeLine() {
            if (lines.length > 0) {
                const randomIndex = Math.floor(Math.random() * lines.length);
                const lineToRemove = lines[randomIndex];
                scene.remove(lineToRemove);
                lineToRemove.geometry.dispose();
                lineToRemove.material.dispose();
                lines.splice(randomIndex, 1);
            }
        }


        // Animation loop for the equalizer and visualization
        function animateEqualizer() {
            requestAnimationFrame(animateEqualizer);

            // Removed the rotation based on mouseX here


            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray); // Get frequency data

                const dataArrayLength = dataArray.length;
                const color = new THREE.Color();

                // Calculate overall spectral complexity
                let totalAmplitude = 0;
                let activeBins = 0;
                const amplitudeThreshold = 20; // Threshold to consider a bin "active"

                for (let i = 0; i < dataArrayLength; i++) {
                    totalAmplitude += dataArray[i];
                    if (dataArray[i] > amplitudeThreshold) {
                        activeBins++;
                    }
                }
                const averageAmplitude = totalAmplitude / dataArrayLength;
                const normalizedAverageAmplitude = averageAmplitude / 255;

                // Determine target line count based on complexity
                // Simple mapping: more active bins = more lines
                const complexityFactor = activeBins / dataArrayLength; // Ratio of active bins
                let targetLineCount = Math.round(minLineCount + complexityFactor * (maxLineCount - minLineCount));
                 targetLineCount = Math.max(minLineCount, Math.min(maxLineCount, targetLineCount)); // Clamp within min/max


                // Adjust line count dynamically
                while (lines.length < targetLineCount) {
                    // Add lines, distributing across frequency ranges with their assigned initial color
                    const linesPerSection = Math.floor(targetLineCount / 3);
                    let frequencyRangeToAdd;
                    // Add new lines with random colors
                    const colorToAdd = new THREE.Color(Math.random(), Math.random(), Math.random()); // Completely random color


                    // Simple logic to try and balance ranges when adding
                    const bassLines = lines.filter(line => line.userData.frequencyRange === 'bass').length;
                    const midsLines = lines.filter(line => line.userData.frequencyRange === 'mids').length;
                    const trebleLines = lines.filter(line => line.userData.frequencyRange === 'treble').length;

                    if (bassLines <= midsLines && bassLines <= trebleLines) {
                        frequencyRangeToAdd = 'bass';
                    } else if (midsLines <= bassLines && midsLines <= trebleLines) {
                        frequencyRangeToAdd = 'mids';
                    } else {
                        frequencyRangeToAdd = 'treble';
                    }
                    addLine(frequencyRangeToAdd, colorToAdd);
                }

                while (lines.length > targetLineCount) {
                    removeLine();
                }


                lines.forEach((line, i) => {
                    const positions = line.geometry.attributes.position.array;
                    const colors = line.geometry.attributes.color.array;

                    // Determine the frequency range for this line
                    const range = frequencyRanges[line.userData.frequencyRange];

                    const startIndex = range[0];
                    const endIndex = range[1];
                    const rangeLength = endIndex - startIndex + 1;

                    // Calculate the average amplitude for this line's frequency range
                    let averageAmplitude = 0;
                    if (rangeLength > 0) {
                        for (let j = startIndex; j <= endIndex; j++) {
                            averageAmplitude += dataArray[j];
                        }
                        averageAmplitude /= rangeLength;
                    }
                    const normalizedAmplitude = averageAmplitude / 255; // Normalize to 0-1

                    // Apply non-linear scaling for more dramatic effect
                    const dramaticAmplitude = Math.pow(normalizedAmplitude, 2); // Squaring makes low values smaller relative to high values

                    // Scale line length based on dramatic amplitude - Adjusted multiplier for shorter lines
                    const extendedLength = dramaticAmplitude * 50; // Reduced multiplier


                    // Calculate the end point of the line based on amplitude and direction and extended length
                    const endPoint = line.userData.direction.clone().multiplyScalar(extendedLength);

                    // Update the end vertex position
                    positions[3] = endPoint.x;
                    positions[4] = endPoint.y;
                    positions[5] = endPoint.z;


                    // Update vertex colors based on amplitude and the line's current color (either initial or random)
                    // Use the stored initialColor as the base for HSL adjustment
                    const baseColor = line.userData.initialColor;
                    const hsl = { h: 0, s: 0, l: 0 }; // Temporary object for HSL values
                    baseColor.getHSL(hsl); // Get HSL from the base color

                    // Adjust lightness based on original normalized amplitude, relative to base lightness
                    // Ensure lightness stays within a reasonable range (e.g., 0.2 to 1.0)
                    const minLightness = 0.2; // Minimum lightness
                    const maxLightness = 1.0; // Maximum lightness
                    const lightnessRange = maxLightness - minLightness;
                    const adjustedLightness = minLightness + normalizedAmplitude * lightnessRange;

                    color.setHSL(hsl.h, hsl.s, adjustedLightness); // Set color using HSL from base and adjusted lightness


                    colors[0] = color.r; // Color of the start vertex
                    colors[1] = color.g;
                    colors[2] = color.b;
                    colors[3] = color.r; // Color of the end vertex
                    colors[4] = color.g;
                    colors[5] = color.b;


                    line.geometry.attributes.position.needsUpdate = true; // Mark positions as needing update
                    line.geometry.attributes.color.needsUpdate = true; // Mark colors as needing update

                    // Apply rotation
                    line.rotation.x += line.userData.rotationSpeed.x;
                    line.rotation.y += line.userData.rotationSpeed.y;
                    line.rotation.z += line.userData.rotationSpeed.z;
                });

            }

            // Animate stars (subtle movement and shooting stars)
            if (stars && starData.length > 0) {
                 const starPositions = stars.geometry.attributes.position.array;
                 const starSizes = stars.geometry.attributes.size.array; // Get sizes array
                 const starLifes = stars.geometry.attributes.life.array; // Get lifes array
                 const starColorsArray = stars.geometry.attributes.color.array; // Get colors array
                 const starCountActual = stars.geometry.attributes.position.count;
                 const currentTime = performance.now();
                 const deltaTime = (currentTime - (animateEqualizer.lastTime || currentTime)) / 1000; // Delta time in seconds
                 animateEqualizer.lastTime = currentTime;


                for (let i = 0; i < starCountActual; i++) {
                    const starIndex = i * 3;
                    const currentStarData = starData[i];

                    if (currentStarData.isShooting) {
                        // Move the shooting star
                        starPositions[starIndex] += currentStarData.shootingDirection.x * currentStarData.shootingSpeed * deltaTime * 60; // Scale by delta time
                        starPositions[starIndex + 1] += currentStarData.shootingDirection.y * currentStarData.shootingSpeed * deltaTime * 60;
                        starPositions[starIndex + 2] += currentStarData.shootingDirection.z * currentStarData.shootingSpeed * deltaTime * 60;

                        // Decrease life
                        currentStarData.life -= deltaTime / (shootingStarDuration / 1000); // Decrease life based on duration
                        currentStarData.life = Math.max(0, currentStarData.life); // Clamp life to 0

                        // Update life attribute for fading (if using alpha in material)
                        starLifes[i] = currentStarData.life;

                        // Update size based on life (grows then shrinks)
                        const sizeFactor = 1.0 - currentStarData.life; // Goes from 0 to 1 as life goes from 1 to 0
                        starSizes[i] = currentStarData.initialSize + sizeFactor * 1.5; // Grows up to 1.5 units larger

                        // Check if the shooting star has faded out
                        if (currentStarData.life <= 0) {
                             // Reset to a new random position and stop shooting
                             const radius = Math.random() * 800 + 100;
                             const theta = Math.random() * Math.PI * 2;
                             const phi = Math.acos((Math.random() * 2) - 1);
                             starPositions[starIndex] = radius * Math.sin(phi) * Math.cos(theta);
                             starPositions[starIndex + 1] = radius * Math.sin(phi) * Math.sin(theta);
                             starPositions[starIndex + 2] = radius * Math.cos(phi);

                            currentStarData.initialPosition.set(starPositions[starIndex], starPositions[starIndex + 1], starPositions[starPositions[starIndex + 2]]); // Update initial position

                            currentStarData.isShooting = false;
                            currentStarData.life = 1.0; // Reset life
                            starLifes[i] = 1.0; // Reset life attribute
                            starSizes[i] = currentStarData.initialSize; // Reset size attribute
                            isShootingStarActive = false; // Allow a new shooting star
                        }

                    } else {
                        // Subtle random drift for non-shooting stars
                         starPositions[starIndex] += (Math.random() - 0.5) * 0.01 * deltaTime * 60; // Scale by delta time
                         starPositions[starIndex + 1] += (Math.random() - 0.5) * 0.01 * deltaTime * 60;
                         starPositions[starIndex + 2] += (Math.random() - 0.5) * 0.01 * deltaTime * 60;

                        // Keep non-shooting stars within a large boundary
                        const starPos = new THREE.Vector3(starPositions[starIndex], starPositions[starIndex + 1], starPositions[starIndex + 2]);
                        if (starPos.length() > 900) {
                            const radius = Math.random() * 800 + 50;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            starPositions[starIndex] = radius * Math.sin(phi) * Math.cos(theta);
                            starPositions[starIndex + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            starPositions[starIndex + 2] = radius * Math.cos(phi);
                             // Update initial position when resetting
                            currentStarData.initialPosition.set(starPositions[starIndex], starPositions[starIndex + 1], starPositions[starIndex + 2]);
                        }


                        // Occasionally make a star a shooting star, respecting the interval and active state
                        if (!isShootingStarActive && (currentTime - lastShootingStarTime > shootingStarInterval) && Math.random() < 0.0002) { // Adjusted probability
                             // Find a non-shooting star to make it a shooting star
                             if (!currentStarData.isShooting) {
                            currentStarData.isShooting = true;
                            isShootingStarActive = true; // Set flag that a shooting star is active
                            lastShootingStarTime = currentTime; // Record the time
                                currentStarData.life = 1.0; // Reset life for the new shooting star

                            // Random shooting direction
                            currentStarData.shootingDirection.set(
                                (Math.random() - 0.5) * 2,
                                (Math.random() - 0.5) * 2,
                                (Math.random() - 0.5) * 2
                            ).normalize();
                            currentStarData.shootingSpeed = Math.random() * 2 + 1; // Random shooting speed
                             // Start the shooting star from its current position
                             currentStarData.initialPosition.set(starPositions[starIndex], starPositions[starIndex + 1], starPositions[starIndex + 2]);
                                 break; // Only make one shooting star at a time
                             }
                        }
                    }
                }
                stars.geometry.attributes.position.needsUpdate = true; // Important to update the buffer geometry
                stars.geometry.attributes.size.needsUpdate = true; // Update sizes
                stars.geometry.attributes.life.needsUpdate = true; // Update life for opacity
            }


            // Move camera based on mouse position (only if not dragging)
            if (!isDragging) {
                camera.position.x += (mouseX * 0.04 - camera.position.x) * 0.01; // Slower camera movement
                camera.position.y += (-mouseY * 0.04 - camera.position.y) * 0.01;
                camera.lookAt(scene.position); // Make camera look at the center of the scene
            }


            renderer.render(scene, camera);
        }

        // Handle mouse movement for camera control (only if not dragging)
        function onDocumentMouseMove(event) {
            if (!isDragging) {
                mouseX = (event.clientX - windowHalfX);
                mouseY = (event.clientY - windowHalfY);
            }
        }

         // Handle mouse wheel for zooming
        function onDocumentMouseWheel(event) {
            // Adjust camera position based on wheel direction
            camera.position.z += event.deltaY * 0.2; // Zoom in/out by changing Z position

            // Optional: Limit zoom range
            camera.position.z = Math.max(40, Math.min(600, camera.position.z)); // Adjusted zoom limits
        }

         // Handle click on the canvas - Change line colors to new random colors
        function onCanvasClick(event) {
             lines.forEach(line => {
                 // Assign a new completely random color to this line's vertices
                 const newRandomColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                 const colors = line.geometry.attributes.color.array;
                  for(let i = 0; i < colors.length; i += 3) {
                     colors[i] = newRandomColor.r;
                     colors[i+1] = newRandomColor.g;
                     colors[i+2] = newRandomColor.b;
                 }
                 line.geometry.attributes.color.needsUpdate = true;
                 // Update the initialColor in userData so the brightness scaling uses the new random color
                 line.userData.initialColor = newRandomColor;
             });
        }

        // Handle mouse down for dragging
        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        // Handle mouse up for dragging
        function onMouseUp(event) {
            isDragging = false;
        }

        // Handle mouse move for dragging and rotation
        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;

                // Rotate the scene based on mouse movement
                // Lowered sensitivity for slower drag speed
                scene.rotation.y += deltaX * 0.002; // Reduced multiplier
                scene.rotation.x += deltaY * 0.002; // Reduced multiplier

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            } else {
                // Update mouse position for camera control when not dragging
                 mouseX = (event.clientX - windowHalfX);
                 mouseY = (event.clientY - windowHalfY);
            }
        }


        // Handle window resize
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize Three.js when the window loads
        window.onload = function () {
            initThree();
            // Equalizer animation starts when audio is loaded and played
        }

        function playDefaultAudio() {
            fetch('music/music-metadata.json')
                .then(response => response.json())
                .then(data => {
                    const audioUrl = 'music/' + data.filename;
                    loadAudioFromUrl(audioUrl);
                })
                .catch(error => console.error('Error fetching music metadata:', error));
        }

        function loadAudioFromUrl(url) {
            const request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = 'arraybuffer';

            request.onload = function() {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.decodeAudioData(request.response, function(buffer) {
                    if (source) {
                        source.stop();
                        source.disconnect();
                    }
                    initAudio(buffer);
                    document.getElementById('upload-icon-container').style.display = 'none';
                    document.getElementById('file-info-bottom').style.display = 'flex';
                    document.getElementById('file-name-bottom').textContent = url.split('/').pop();
                }, function(e) {
                    console.error("Error decoding audio data", e);
                    resetAudio();
                });
            };

            request.send();
        }
        </script>
    </body>
</html>
